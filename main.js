/*
변수란? 프로그래밍 언어에서 데이터를 관리하기 위한 개념
인간의 논리 해석과정처럼 컴퓨터도 이에 해당하는 과정이 있습니다
따라서 js도 코드를 평가하려면 리터럴, 연산자라는 기호의 의미와
표현식의 해석이 가능해야 CPU에서 연산하고 메모리를 통해서 데이터를
기억하고 해석할 수 있는것
js에서 어떤 식이나 값이 생성되면 메모리에 저장하는데,
각 메모리는 고유 메모리 주소를 가지며, 값은 2진수로 저장됨

따라서 변수란?
하나의 값을 저장하기 위해서 확보한 메모리 공간자체, 혹은 그 메모리
공간의 이름이라고도 할 수 있습니다

변수는 변수이름과 변수 값으로 이루어져 있으며, 
변수이름을 식별자라고도 부릅니다
즉 변수이름, 식별자는 값을 기억하는 것이 아니라 
메모리 주소를 기억하는것
변수에 식별자, 이름을 붙이는것은 선언에 의해 
자바스크립트에게 알리는것

변수선언과정 : 변수를 사용하기 위해서는 선언, 즉 생성해야 합니다
변수선언에는 var, let, const라는 방법이 존재합니다
변수 선언의 과정 
1. 선언단계 : 변수 이름을 등록해서, 자바스크립트 엔진에 변수존재를
알림
2. 초기화단계 : 값을 저장하기 위한 메모리 공간을 확보하고
암묵적으로 undefined를 할당하여 초기화
이런 과정을 거친 변수가 선언되면, 변수이름, 식별자는 
실행 컨텍스트라는 자바스크립트 엔진이 코드를 평가하고 실행하기 위한
관리영역에 등록되어 관리됩니다
실행 컨텍스트 : 단순하게 코드의 실행순서, 범위등을 관리하며
실행중 변수나 함수의 식별자들을 해석하는 도움을 주는 도우미

변수가 중복되면, 마지막에 코딩한 값이 덮어써져서 재할당이 일어난다
var 로 선언하는 변수는 변수의 중복선언을 허용합니다

변수를 사용하려면, 변수의 이름을 부르면 변수를 사용할 수 있습니다
이것을 변수를 사용한다 혹은 변수를 참조한다고 표현합니다

변수선언과 호이스팅
호이스팅이란 변수선언이 스코프의 선두로 끌어져 올려진 것처럼
동작하는 자바스크립트의 고유 특징입니다
변수의 선언이 소스코드의 한줄씩 순차적으로 실행되는 시점, 즉
런타임이 아니라 그 이전 단계에서 먼저 실행되는데,
자바스크립트 엔진은 실행을 위한 준비단계인 소스코드 평가의 과정에서
변수선언을 포함한 모든 선언문을 소스코드에서 모두 찾아서 먼저 실행함
따라서 문서 처음 단계에서 문서안의 모든 선언문을 이미 알고 시작합니다
그리고 소스코드 평가가 끝나면 한줄씩 순차적으로 실행하는 과정을 
거치는데 이때 일어나는 이미 알고 시작하는 현상을 호이스팅이라고 하는것

변수의 스코프 : 변수가 영향을 미치는 범위
1. 전역 변수 : 자바스크립트 최상단 즉 코드의 가장 바깥영역에서
선언된(즉 {}코드블록 안에서 선언되지 않은) 변수로
자바스크립트 전체에 걸쳐서 영향을 미치는 변수입니다

특징 : 따라서 전역변수는 코드 어디서든지 참조하고,
할당할 수 있는 변수이기 때문에
1) 암묵적 결합 : 즉 모든 코드가 전역변수를 참조하고 변경할 수 있음
-> 변수의 스코프는 클 수록 가독성은 나빠지고, 위험성도 높아진다
2) 긴 생명주기 : 전역변수는 해당 문서가 유효하는한 생존하며,
따라서 메모리 누수가 크다
3) 네임스페이스 오염 : 
네임스페이스는 변수이름들을 관리하는 자바스크립트 내부의 공간
자바스크립트는 파일을 분리하더라도 같은 html에 연결되어있으면
하나의 전역 스코프를 공유하기 때문에 두 분리된 파일의 전역변수를
공유하게 됩니다 
이유는 전역변수나 전역함수등은 같은 스코프에 존재하기때문


2. 지역 변수 : 함수안에, 코드블록안에 선언된 변수로
해당 함수, 코드블록 안에서 선언되고 사용됩니다
지역변수는 자신의 지역스코프와 하위 지역스코프에서만 유효하고
var로 선언된 변수는 오직 함수의 코드 블록만 지역변수로 인정된다

블록레벨 스코프 : 대부분의 프로그래밍언어는 {} 코드블록이
지역스코프를 만드는데 이것을 블록레벨 스코프라고 합니다
 
함수레벨 스코프 : var키워드로 선언된 변수는 오직 함수의 
코드블록만 지역스코프로 인정하는데 이런 자바스크립트의 특징을
함수레벨 스코프라고 한다

1. 동적 스코프 : 즉 호출을 어느곳에서 하였는지에 따라서 
동적으로 상위 스코프가 변경되는 방식을 동적 스코프라고 한다

2. 정적 스코프 : 다른말로 렉시컬 스코프 
자바스크립트는 이방법으로 상위 스크포를 정하며, 정의되는 지점에서의
상위 스크포가 고정되는 방식입니다
=> 이에 따라서 자바스크립트는 함수를 어느곳에 만들든지 상관이없음

== 변수의 생명주기
변수는 선언에 의해서 생성되고, 할당에 의해서 값을 가집니다
그리고 이후에 종류에 따라서 소멸되는 시간이 있는데
이것을 변수의 생명주기라고 합니다

변수의 생명주기가 없다면?? 변수는 계속해서 메모리공간을 차지하게됨
결론적으로 변수의 생명주기는 변수의 스코프와 관련있으며,
스코프가 끝나는 지점이 소멸, 마감합니다

==변수 이름의 규칙
1. 숫자로 시작할 수는 없습니다
2. 특수문자는 사용이 불가능 (단, $, _ 사용가능 )
3. - 사용불가능함
4. 예약어 모두안됨 (예약어란 자바스크립트가 사용하는 단어)
5. 대소문자는 구분되어야하고, 서로다른 변수가된다
6. 한글변수는 가능은 하지만 , 피하게는 좋다
+ 변수끼리 연산도 가능합니다

=== 네이밍 컨벤션 (표기법)
user + details
카멜 - 두 단어가 합쳐진 네이밍에서 표기를, 중간에 대문자를 사용해서
결합하는 방법
userDetails
스네이크 - 두단어가 합쳐진 네이밍에서 표기를 _로 이어주는 방법
user_details
파스칼 - 두단어가 합쳐질때 단어의 맨앞글자만 대문자로 사용해서
이어주는 방법, 나머지는 소문자를 사용
UserDetails
헝가리언 - 데이터 타입을 변수 이름앞에 붙여서 표기하는 방식
strUserdetails


---- 변수선언방법의 종류
1. var
es5 까지의 방법이며 여러가지의 문제점이 있다
문제점 1 : 변수 중복선언을 허용한다
코드를 작성면서 변수값이 변경되는 부작용이 비일비재하게 발생하게 된다
문제점 2 : 함수 레벨 스코프
var로 선언하면 함수코드블록만 지역변수로 인식되고 나머지는 전역변수로
인식하기 때문에, 지역변수의 할당이 어려워진다
문제점 3 : 호이스팅
2. let
es6이후 var의 문제점을 개선한 방법입니다
해결 방안 1 . 변수 중복선언을 금지
var aaa = 33;
var aaa = 333;

let bbb = 333;
let bbb = 444; //밑줄이 그어져 오류를 발생함

해결방안 2. 블록레벨 스코프
let abcd = 1;

if (true) {
    let abcd = 10
}
console.log(abcd); //var를 썼을떄는 10이 let을쓰면 1이 출력된다

해결방안 3. 호이스팅문제 해결(된것 처럼 보임)
let으로 변수를 선언할 경우 선언과 초기화 단계 사이에
"일시적 사각지대"를 설정하여, 변수 선언을 초기화 전에 참조할수 없게함
// console.log(aaa);  //레퍼럴스 에러가 일어남
let aaa;
console.log(aaa); //언디파인드가 출력됨
//출력된다는것은 해당 aaa의 존재를 알고있다는 뜻으로
//호이스팅이 일어났다고 볼수있음
즉 호이스팅이 없었다면 aaa의 존재를 변수선언상태인 지금상태에서는
존재를 몰라서 에러가 발생해야함
aaa = 333;
console.log(aaa);


let abc = 1;
{
    console.log(abc); //레퍼런스 에러가 발생
    //에러의 발생에 따라서 알수있는것은
    밑에 2라는 값의 변수가 호이스팅이되고있다는 뜻이다
    호이스팅이 없다면 전역변수 abc인 1의 값이 정상적으로 찍힐것
    let abc = 2;
}

3. const

// console.log(stop);
// var stop = "스톱";

// console.log(stop);
// let stop = "스톱";


// console.log(aaa);  //레퍼럴스 에러가 일어남
// let aaa;
// console.log(aaa);
// aaa = 333;
// console.log(aaa);

변수 - 변하는 수, 
상수 - 변하지 않는 값을 담는 것
const는 상수를 지정하는 방법으로 정해져있지만
반드시 상수지정에만 사용하는 것은 아닙니다

상수 지정 방법 - 상수의 이름을 모두 대문자로 선언한다
그렇게되면 상수가 되어 값을 온전히 보존하게 됨
const ROUNDNUMBER = 3.14;

let과 거의 동일하며 다른 부분만 살펴본다면
const는 반드시 선언과 동시와 초기화작업을 하여야 문법에러가 발생하지
않습니다
상수로 취급되기 때문에 변수의 재할당이 불가능하지만,
이후로 배울 데이터타입에 따라서 변수처럼 재할당도 가능합니다

주의) const키워드는 재할당을 방지할뿐, 불변성을 담보하는 것은 아님

*/

let aaa = 33; //let으로 변수 선언과 동시에 초기화하여 값을 넣은 것
console.log(aaa);
aaa = 44; //기존변수에 값을 덮어쓰는 재할당이 일어난 것
console.log(aaa);

const con = 333;
console.log(con);
con = 555;
console.log(con);

let abc = 1;
{
    console.log(abc);
    let abc = 2;
}



// let abcd = 1;

// if (true) {
//     let abcd = 10
// }
// console.log(abcd);

// var i = 10;
// for (var i = 0; i < 5; i++) {
//     console.log(i);
// }
// console.log(i);


// var f = 10;


// function abc() {
//     var f = 34;
//     console.log(f);
// }
// abc();
// console.log(f);


// var countingNumber = 100;
// var a = 1;
// var b = 2;
// console.log(a);
// var a = 100;

// console.log(a);

// var countingNumber = 1000;


// var 안녕 = "안녕";
// var good = "안녕";

// var a = 3;
// var b = 7;
// var result = a + b;
// console.log(result);


var day;
console.log(day);
day = 30;
console.log(day);

var student; //전역변수
student = "학생";
console.log(student);
var student = "오은택";
console.log(student);

// function abc() {
//     var sum = 30; //지역변수
// }


// console.log(stop);
// var stop = "스톱";

console.log(test);


var x = 1;
function and() {
    var x = 10;
    or();
}

function or() {
    console.log(x);
}

and();
or();